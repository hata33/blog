## 基础概念

### Promise 原理及用法

### async/await 原理

### es6 Generator 原理

### Map 数据结构

Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。

### Set 数据结构

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

### Map 和 Object 的区别

Map 默认不包含任何键，只包含显式插入的键。Object 上会有原型上的键。

Map 的键是有序的，而 Object 的键是无序的。

Map 的键可以是任意值，包括函数、对象或任何基本类型。Object 的键必须是字符串或符号。

Map 的键是唯一的，不会重复。Object 的键是唯一的，如果重复，后面的会覆盖前面的。

Map 的键可以进行迭代，而 Object 的键需要通过 Object.keys() 或 for...of 循环来迭代。

Map 的键值对可以通过 size 属性来获取，而 Object 的键值对需要通过 Object.keys() 或 for...of 循环来获取。

Map 的键值对可以通过 set() 方法来设置，而 Object 的键值对需要通过赋值操作来设置。

Map 的键值对可以通过 get() 方法来获取，而 Object 的键值对需要通过属性访问来获取。

Map 的键值对可以通过 delete() 方法来删除，而 Object 的键值对需要通过 delete

Map 在频繁增删键值对时性能更好，而 Object 在查找键值对时性能更好。

### Proxy 和 Reflect

Proxy(代理) 是 ES6 中新增的一个特性。Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。
Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handler 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。

与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new 运算符对其进行调用，或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的（就像 Math 对象）。

### symbol 数据类型

Symbol 是 ECMAScript 6 引入的一种新的原始数据类型，用来表示独一无二的值。每个 Symbol 值都是唯一的，因此可以用来创建一些独特的标识符。

Symbol 值通过 Symbol 函数生成。

```js
let s = Symbol();
```

Symbol 函数前不能使用 new 命令，否则会报错。这是因为 Symbol 是原始数据类型，不是对象。

Symbol 作为属性名，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames() 返回。

使用场景：

1. 常量的定义
   `const MY_CONST = Symbol('my_const')`
2. 对象的属性名

```js
const obj = {};
const mySymbol = Symbol("my symbol");
obj[mySymbol] = "hello";
console.log(obj[mySymbol]); // 输出：'hello'
```

3. 定义只读属性

```js
const obj = {};
const mySymbol = Symbol("my symbol");
Object.defineProperty(obj, mySymbol, {
  value: "hello",
  writable: false,
});
console.log(obj[mySymbol]); // 输出：'hello'
obj[mySymbol] = "world";
console.log(obj[mySymbol]); // 输出：'hello'
```

4. 私有属性

```js
const _myPrivateProp = Symbol("my_private_prop");
class MyClass {
  constructor() {
    this[_myPrivateProp] = "private value";
  }
  getPrivateValue() {
    return this[_myPrivateProp];
  }
}
```

### call、apply、bind 的区别和用法

call 方法可以改变函数的 this 指向，同时还能传递多个参数。

apply 方法和 call 方法类似，它也可以改变函数的 this 指向，但是它需要传递一个数组作为参数列表。

bind 方法和 call、apply 方法不同，它并不会立即调用函数，而是返回一个新的函数，这个新函数的 this 指向被绑定的对象。

### let 和 const 与 var 的区别

1、不存在变量提升
必须先定义后使用，否则报错

2、暂时性死区
在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

3、不允许重复申明/不允许在函数内部重新申明参数（也算重复申明）

4.1 SE5 的作用域
1）、内层变量覆盖外层的变量
2）、用来计数的循环变量会泄露为全局变量

5、const 是一个常量，一旦声明，就不能改变。而且在申明的时候必须初始化，不能留到后面赋值。

6、在 ES5 里面，var 在全局作用域下申明的变量，会自动生为 window 的属性:
没法在编译过程爆出变量为申明的错误，语法上顶层对象有一个实体含义的对象这样肯定不合适。
用 var 定义的依然会升级为顶层对象(全局对象)window 的属性；但是 let,const 申明则不会。

### js 数据类型

在 `JavaScript` 中，数据类型可以分为两类：原始类型和对象类型。原始类型包括：数字（`number`）、字符串（`string`）、布尔值（`boolean`）、`null`、`undefined`、 `Symbol`（ES6 新增）和 `BigInt`，对象类型包括：对象（`object`）、数组（`array`）、函数（function）等。

基础类型：数字、字符串、布尔值、null 和 undefined 是 JavaScript 中的五种原始类型，它们都是不可变的。每次对原始类型进行操作时，都会创建一个新的原始类型的值

对象类型：
对象类型则是可变的，因为对象、数组、函数等值是通过引用来访问的

### 常见数组排序算法

- 冒泡排序
- 选择排序
- 插入排序
- 快速排序
- 归并排序
- 堆排序

### 解释一下 原型、构造函、实例、原型链 之间的关系

构造函数可以通过 new 来生成一个实例、构造函数也是函数；
函数都有一个 prototype 属性，这个就是原型对象；
原型对象可以通过构造器 constructor 来指向它的构造函数；
实例的**proto**属性，指向的是其构造函数的原型对象；

原型链：从一个实例对象，向上找构造这个实例相关联的对象，相关联的对象又向上找，找到创造它的一个实例对象，
一直到 Object.prototype 截止。原型链是通过 prototype 和**proto**向上找的。构造函数通过 prototype 创建了很多方法，
被其所有实例所公用，存放在原型对象上；

instanceof 原理

实例对象上面有一个**proto** ，这个是引用的它构造函数的原型对象；

instanceof 是用来判断实例是不是由某个构造函数实例化出来的对象，其原理是判断实例对象是否指向构造函数的原型；
只要是在原型链上的函数，都会被 instanceof 看做是实例对象的一个构造函数，所以都会返回 true;

new 运算符
后面跟着的是一个构造函数，使一个新对象被创建。

Object.create()

创建的实例对象是指向的对象原型，实例对象本身是不具备创建对象的属性和方法的，是通过原型链来链接的。

### DOM 事件

DOM 事件模型、DOM 事件流、DOM 事件捕获的具体流程、Event 对象的常见应用、自动触发事件

常见 DOM 事件

- UI 事件，当用户与页面上的元素交互时触发，如：load、scroll
- 焦点事件，当元素获得或失去焦点时触发，如：blur、focus
- 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup
- 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel
- 文本事件，当在文档中输入文本时触发，如：textInput
- 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress

DOM 事件流

DOM 事件流指的是事件从文档的顶层流动到底层，然后返回的过程。事件流分为两个阶段：事件捕获和事件冒泡。

捕获（从上到下）、冒泡（从下到上）；

捕获->目标阶段->冒泡

### js 闭包

闭包（closure）是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。

闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。

[mdn 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

示例

```js
function makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12
```

js 闭包的用途

1. 保持变量私有

```js
function createCounter() {
  let count = 0; // 私有变量

  function increment() {
    count++;
    console.log(count);
  }

  return increment;
}

const counter = createCounter();
counter(); // 输出: 1
counter(); // 输出: 2
```

2. 模拟模块化

防止污染全局变量

```js
const moduleA = (function () {
  const privateData = "private";

  function privateMethod() {
    console.log(privateData);
  }

  return {
    publicMethod: function () {
      privateMethod();
    },
  };
})();

moduleA.publicMethod(); // 输出: 'private'
```

3. 保存状态

闭包可以用来保存函数之间共享的状态，这种状态可以在多次调用之间持久化。

```js
function createAdder(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = createAdder(5);
console.log(add5(3)); // 输出: 8
```

### js 中的 this 指向

箭头函数的 this 指向声明时所在作用域下的 this 值。

1. 所有的 this 关键字，在函数运行时，才能确定它的指向
2. this 所在的函数由哪个对象调用，this 就会指向谁
3. 在函数调用中 this 指向 window 对象
4. 在对象中调用函数 this 指向调用这个函数的对象
5. 在构造函数中 this 指向实例出来的对象
6. 在 call apply bind 中 this 指向第一个参数，bind 特殊，需要手动执行这个函数。
7. 箭头函数中的 this 指向调用这个函数的外层对象。有时是 window.
   （箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this。

## 代码场景

### 如何检查对象循环引用

使用 WeakSet 特性解决；

```js
// 对 传入的 subject 对象 内部存储的所有内容执行回调
function execRecursively(fn, subject, _refs = new WeakSet()) {
  // 避免无限递归
  if (_refs.has(subject)) {
    return;
  }

  fn(subject);
  if (typeof subject === "object") {
    _refs.add(subject);
    for (const key in subject) {
      execRecursively(fn, subject[key], _refs);
    }
  }
}

const foo = {
  foo: "Foo",
  bar: {
    bar: "Bar",
  },
};

foo.bar.baz = foo; // 循环引用！
execRecursively((obj) => console.log(obj), foo);
```

### ajax 如何获取下载进度

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "file.url", true);
xhr.responseType = "blob";
xhr.onprogress = function (event) {
  if (event.lengthComputable) {
    const percentComplete = (event.loaded / event.total) * 100;
    console.log(`Downloaded ${percentComplete}%`);
  }
};
xhr.onload = function (event) {
  // 文件下载完成
  const blob = xhr.response;
};
xhr.send();
```

### 手写创建 ajax 请求

一般来说，我们可以使用 XMLHttpRequest 对象来创建 Ajax 请求，其流程如下：

1. 创建 XMLHttpRequest 对象，通过调用其构造函数来实现。
2. 使用 open()方法指定请求的方法、URL 以及是否异步请求。
3. 使用 setRequestHeader()方法设置请求头，例如设置请求的 Content-Type。
4. 设置响应的回调函数，一般有 onreadystatechange 和 onload 两种方式。
5. 使用 send()方法发送请求。

```JS
var getJSON = function(url) {
  var promise = new Promise(function(resolve, reject) {
    function handler() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    }

    var client = new XMLHttpRequest();
    //如果是IE的内核ActiveXObject('Microsoft.XMLHTTP');
    client.open("GET", url);
    client.onreadystatechange = handler;
    client.responseType = "json";
    client.setRequestHeader("Accept", "application/json");
    //如果是post请求：client.setRequestHeader('Content-Type','application/X-WWW-form-urlencoded')
    client.send();
  });
  return promise;
};

getJSON("/posts.json").then(function(json) {
  console.log('Contents: ' + json);
}, function(error) {
  console.error(' 出错了 ', error);
});
```

### JS 有哪些迭代器

在 JavaScript 中，有三种类型的迭代器：

- Array Iterator（数组迭代器）：通过对数组进行迭代以访问其元素。
- String Iterator（字符串迭代器）：通过对字符串进行迭代以访问其字符。
- Map Iterator（映射迭代器）和 Set Iterator（集合迭代器）：通过对 Map 和 Set 数据结构进行迭代以访问其键和值。

### 如何使对象 iterable 化， 以其可以支持 for...of 迭代

```js
const myObj = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.data.length) {
          return { value: this.data[index++], done: false };
        } else {
          return { done: true };
        }
      },
    };
  },
};

for (const item of myObj) {
  console.log(item);
}
// 输出：1, 2, 3
```

### js 对象可以使用 for...of 迭代吗

JavaScript 对象本身并不能直接使用 for...of 迭代，因为它并不是一个可迭代对象（iterable）。

但是，如果我们想要遍历对象的属性，可以使用 for...in 循环

```js
const obj = {
  name: 'John',
  age: 30,
  city: 'New York'
};

for (let prop in obj) {
  console.log(prop + ': ' + obj[prop]);
}

// 这段代码可以输出：
name: John
age: 30
city: New York

const obj = {
  name: 'John',
  age: 30,
  city: 'New York'
};
// 使用 hasOwnProperty() 方法进行判断对象自身的属性
for (let prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(prop + ': ' + obj[prop]);
  }
}
```

### 实现一个双向链表

具备添加节点、删除节点、在特定位置插入节点、查找节点、遍历等功能

```js
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  // 在链表末尾添加节点
  push(value) {
    const node = new Node(value);
    if (this.length === 0) {
      this.head = node;
      this.tail = node;
    } else {
      this.tail.next = node;
      node.prev = this.tail;
      this.tail = node;
    }
    this.length++;
    return this;
  }

  // 从链表末尾移除节点
  pop() {
    if (this.length === 0) {
      return undefined;
    }
    const node = this.tail;
    if (this.length === 1) {
      this.head = null;
      this.tail = null;
    } else {
      this.tail = node.prev;
      this.tail.next = null;
      node.prev = null;
    }
    this.length--;
    return node.value;
  }

  // 在链表开头添加节点
  unshift(value) {
    const node = new Node(value);
    if (this.length === 0) {
      this.head = node;
      this.tail = node;
    } else {
      this.head.prev = node;
      node.next = this.head;
      this.head = node;
    }
    this.length++;
    return this;
  }

  // 从链表开头移除节点
  shift() {
    if (this.length === 0) {
      return undefined;
    }
    const node = this.head;
    if (this.length === 1) {
      this.head = null;
      this.tail = null;
    } else {
      this.head = node.next;
      this.head.prev = null;
      node.next = null;
    }
    this.length--;
    return node.value;
  }

  // 获取指定位置的节点
  get(index) {
    if (index < 0 || index >= this.length) {
      return undefined;
    }
    let node = null;
    if (index < this.length / 2) {
      node = this.head;
      for (let i = 0; i < index; i++) {
        node = node.next;
      }
    } else {
      node = this.tail;
      for (let i = this.length - 1; i > index; i--) {
        node = node.prev;
      }
    }
    return node;
  }

  // 在指定位置插入节点
  insert(index, value) {
    if (index < 0 || index > this.length) {
      return false;
    }
    if (index === 0) {
      return !!this.unshift(value);
    }
    if (index === this.length) {
      return !!this.push(value);
    }
    const node = new Node(value);
    const prevNode = this.get(index - 1);
    const nextNode = prevNode.next;
    prevNode.next = node;
    node.prev = prevNode;
    node.next = nextNode;
    nextNode.prev = node;
    this.length++;
    return true;
  }

  // 移除指定位置的节点
  remove(index) {
    if (index < 0 || index >= this.length) {
      return undefined;
    }
    if (index === 0) {
      return this.shift();
    }
    if (index === this.length - 1) {
      return this.pop();
    }
    const nodeToRemove = this.get(index);
    const prevNode = nodeToRemove.prev;
    const nextNode = nodeToRemove.next;
    prevNode.next = nextNode;
    nextNode.prev = prevNode;
    nodeToRemove.next = null;
    nodeToRemove.prev = null;
    this.length--;
    return nodeToRemove.value;
  }

  // 反转链表
  reverse() {
    let node = this.head;
    this.head = this.tail;
    this.tail = node;
    let prevNode = null;
    let nextNode = null;
    for (let i = 0; i < this.length; i++) {
      nextNode = node.next;
      node.next = prevNode;
      node.prev = nextNode;
      prevNode = node;
      node = nextNode;
    }
    return this;
  }

  // 通过 value 来查询 index
  findIndexByValue(value) {
    let currentNode = this.head;
    let index = 0;

    while (currentNode) {
      if (currentNode.value === value) {
        return index;
      }
      currentNode = currentNode.next;
      index++;
    }

    return -1; // 如果链表中没有找到该值，返回 -1
  }

  // 正向遍历链表，并返回遍历结果
  forwardTraversal() {
    const result = [];
    let current = this.head;
    while (current) {
      result.push(current.value);
      current = current.next;
    }
    return result;
  }

  // 反向遍历链表，并返回遍历结果
  backwardTraversal() {
    const result = [];
    let current = this.tail;
    while (current) {
      result.push(current.value);
      current = current.prev;
    }
    return result;
  }

  // 循环遍历链表，并返回遍历结果
  loopTraversal() {
    const result = [];
    let current = this.head;
    while (current) {
      result.push(current.value);
      current = current.next;
      if (current === this.head) {
        break;
      }
    }
    return result;
  }
}
```

### js 中继承

组合继承

通过 Object.create 来创建原型中间对象，那么这么来的话，child5 的对象 prototype 获得的是 parent5 父类的原型对象；
Object.create 创建的对象，原型对象就是参数；

```js
function Parent5() {
  this.name = "parent5";
  this.play = [1, 2, 3];
}

function Child5() {
  Parent5.call(this);
  this.type = "child5";
}

Child5.prototype = Object.create(Parent5.prototype);
//这个时候虽然隔离了，但是constructor还是只想的Parent5的，因为constructor会一直向上找
Child5.prototype.constructor = Child5;

var s7 = new Child5();
console.log(s7 instanceof Child5, s7 instanceof Parent5);
console.log(s7.constructor);
```

ES6 中继承

Class 可以通过 extends 关键字实现继承，让子类继承父类的属性和方法。

```js
class Point {
  /* ... */
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + " " + super.toString(); // 调用父类的toString()
  }
}
```

### 手写实现一下 lodash.get

lodash.get 是一个 JavaScript 库 Lodash 中的函数，它允许您在对象中安全地获取深层嵌套的属性值，即使在中间的属性不存在时也不会引发错误。以下是一个简单的实现：

```js
function get(object, path, defaultValue) {
  if (!object || !path) {
    return defaultValue;
  }
  const pathArray = path.split(".").filter(Boolean);

  let value = object;
  for (let i = 0; i < pathArray.length; i++) {
    const key = pathArray[i];
    value = value[key];
    if (value === undefined) {
      return defaultValue;
    }
  }

  return value || defaultValue;
}
```

### 深拷贝

```js
// 一:只能用于对象内部没有方法时
JSON.parse(JSON.stringify(obj));

// 二: 递归，简陋版本
// 属性值可以是数组或对象，此时进行递归
// 属性值也可以函数
function deepClone(source) {
  let target = null;
  if (typeof source === "object" && source !== null) {
    target = Array.isArray(source) ? [] : {};
    for (let [key, value] of Object.entries(source)) {
      target[key] = deepClone(value);
    }
  } else {
    target = source;
  }
  return target;
}

// 但无法解决循环引用的问题
// 例如
let obj = {};
obj.a = obj;
deepClone(obj);
// 会一直递归执行deepClone，造成函数栈溢出

// 复杂版本
// 使用WeakMap解决循环引用的问题
// 使用WeakMap而不是Map是因为其使用的弱引用。该引用不会被垃圾回收器记录。
function deepClone(source, hash = new WeakMap()) {
  let target;
  if (hash.has(source)) {
    return hash.get(source);
  }
  if (typeof source === "object" && source !== null) {
    target = Array.isArray(source) ? [] : {};
    hash.set(source, target);
    for (let [key, value] of Object.entries(source)) {
      target[key] = deepClone(value, hash);
    }
  } else {
    target = source;
  }

  return target;
}
var obj = {};
obj.a = obj;
deepClone(obj);
```

使用 `lodash` 的 `cloneDeep`

### 数组去重

使用 ES6 的 Set

```js
// 利用Array.from将Set结构转换成数组
function dedupe(array) {
  return Array.from(new Set(array));
}
dedupe([1, 1, 2, 3]); //[1,2,3]
// 拓展运算符(...)内部使用for...of循环
let arr = [1, 2, 3, 3];
let resultArr = [...new Set(arr)];
console.log(resultArr); //[1,2,3]
```

### 银行卡号四位空一位

```js
var str = "6222023100014763381";
// 移除空白字符并且每四位增加一个空格
var str = str.replace(/\s/g, "").replace(/(.{4})/g, "$1 ");
console.log(str);
```
